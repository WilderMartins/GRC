package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"phoenixgrc/backend/internal/models" // Modelos, incluindo Vulnerability, VulnerabilitySeverity, etc.
	"regexp"                             // Para sqlmock query matching
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"gorm.io/gorm" // Adicionado
)

// Assumindo que testUserID, testOrgID são definidos em main_test_handler.go e acessíveis.
// E que getRouterWithAuthenticatedContext também está disponível e configura o contexto Gin corretamente.

var testVulnID = uuid.New() // Para uso em testes Get, Update, Delete

func TestCreateVulnerabilityHandler(t *testing.T) {
	setupMockDB(t) // Adicionado
	gin.SetMode(gin.TestMode)
	// Roteador com contexto de usuário autenticado (testUserID, testOrgID)
	// Assumindo que testUserID tem permissão (qualquer role autenticado pode criar para sua org)
	router := getRouterWithAuthenticatedContext(testUserID, testOrgID)
	router.POST("/vulnerabilities", CreateVulnerabilityHandler)

	t.Run("Successful vulnerability creation", func(t *testing.T) {
		payload := VulnerabilityPayload{
			Title:         "SQL Injection in Login Form",
			Description:   "User input in login form is not properly sanitized, allowing SQL injection.",
			CVEID:         "CVE-2023-12345",
			Severity:      models.SeverityHigh, // Uses "Alto"
			Status:        models.VStatusDiscovered,
			AssetAffected: "WebApp Login Page",
		}
		body, _ := json.Marshal(payload)

		sqlMock.ExpectBegin()
		// Regex para INSERT INTO "vulnerabilities"
		// Colunas: id, organization_id, title, description, cve_id, severity, status, asset_affected, created_at, updated_at
		sqlMock.ExpectQuery(regexp.QuoteMeta(`INSERT INTO "vulnerabilities" ("id","organization_id","title","description","cve_id","severity","status","asset_affected","created_at","updated_at") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING "id"`)).
			WithArgs(sqlmock.AnyArg(), testOrgID, payload.Title, payload.Description, payload.CVEID, payload.Severity, payload.Status, payload.AssetAffected, sqlmock.AnyArg(), sqlmock.AnyArg()).
			WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(uuid.New().String()))
		sqlMock.ExpectCommit()

		req, _ := http.NewRequest(http.MethodPost, "/vulnerabilities", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)

		assert.Equal(t, http.StatusCreated, rr.Code, "Response code should be 201 Created: %s", rr.Body.String())

		var createdVuln models.Vulnerability
		err := json.Unmarshal(rr.Body.Bytes(), &createdVuln)
		assert.NoError(t, err)
		assert.Equal(t, payload.Title, createdVuln.Title)
		assert.Equal(t, testOrgID, createdVuln.OrganizationID)
		assert.NotEqual(t, uuid.Nil, createdVuln.ID)

		assert.NoError(t, sqlMock.ExpectationsWereMet(), "SQL mock expectations were not met")
	})

	t.Run("Invalid payload - missing title", func(t *testing.T) {
		payload := VulnerabilityPayload{Description: "Only description", Severity: models.SeverityLow} // Title é obrigatório, SeverityLow usa "Baixo"
		body, _ := json.Marshal(payload)

		req, _ := http.NewRequest(http.MethodPost, "/vulnerabilities", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusBadRequest, rr.Code)
	})

    t.Run("Invalid payload - invalid severity", func(t *testing.T) {
		// Usando Marshal para criar um JSON com valor inválido para severity
		invalidPayloadJSON := `{"title": "Test Vuln", "severity": "super_high"}`

		req, _ := http.NewRequest(http.MethodPost, "/vulnerabilities", bytes.NewBuffer([]byte(invalidPayloadJSON)))
		req.Header.Set("Content-Type", "application/json")
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusBadRequest, rr.Code) // Gin binding deve falhar
	})
}

func TestGetVulnerabilityHandler(t *testing.T) {
	setupMockDB(t) // Adicionado
	gin.SetMode(gin.TestMode)
	router := getRouterWithAuthenticatedContext(testUserID, testOrgID)
	router.GET("/vulnerabilities/:vulnId", GetVulnerabilityHandler)

	t.Run("Successful get vulnerability", func(t *testing.T) {
		mockVuln := models.Vulnerability{
			ID:             testVulnID,
			OrganizationID: testOrgID,
			Title:          "Test Vulnerability to Fetch",
			Severity:       models.SeverityMedium, // Uses "Médio"
			Status:         models.VStatusInRemediation,
			CreatedAt:      time.Now(),
			UpdatedAt:      time.Now(),
		}

		rows := sqlmock.NewRows([]string{"id", "organization_id", "title", "severity", "status", "created_at", "updated_at"}).
			AddRow(mockVuln.ID, mockVuln.OrganizationID, mockVuln.Title, mockVuln.Severity, mockVuln.Status, mockVuln.CreatedAt, mockVuln.UpdatedAt)

		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2 ORDER BY "vulnerabilities"."id" LIMIT $3`)).
			WithArgs(testVulnID, testOrgID, 1).
			WillReturnRows(rows)

		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("/vulnerabilities/%s", testVulnID.String()), nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)

		assert.Equal(t, http.StatusOK, rr.Code, "Response code should be 200 OK: %s", rr.Body.String())
		var fetchedVuln models.Vulnerability
		err := json.Unmarshal(rr.Body.Bytes(), &fetchedVuln)
		assert.NoError(t, err)
		assert.Equal(t, mockVuln.Title, fetchedVuln.Title)
		assert.Equal(t, mockVuln.ID, fetchedVuln.ID)

		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})

	t.Run("Vulnerability not found", func(t *testing.T) {
		nonExistentID := uuid.New()
		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2`)).
			WithArgs(nonExistentID, testOrgID).
			WillReturnError(gorm.ErrRecordNotFound)

		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("/vulnerabilities/%s", nonExistentID.String()), nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusNotFound, rr.Code)
		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})

    t.Run("Vulnerability belongs to another organization", func(t *testing.T) {
        // Mock GORM para não encontrar o registro com testOrgID
		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2`)).
            WithArgs(testVulnID, testOrgID). // testVulnID é o ID, testOrgID é do token
			WillReturnError(gorm.ErrRecordNotFound) // O item não será encontrado para esta org

		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("/vulnerabilities/%s", testVulnID.String()), nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusNotFound, rr.Code) // Ou Forbidden, dependendo da lógica exata. NotFound é comum.
		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})
}


func TestListVulnerabilitiesHandler(t *testing.T) {
	setupMockDB(t) // Adicionado
	gin.SetMode(gin.TestMode)
	router := getRouterWithAuthenticatedContext(testUserID, testOrgID)
	router.GET("/vulnerabilities", ListVulnerabilitiesHandler)

	t.Run("Successful list vulnerabilities", func(t *testing.T) {
		mockVulns := []models.Vulnerability{
			{ID: uuid.New(), OrganizationID: testOrgID, Title: "Vuln A", Severity: models.SeverityLow, Status: models.VStatusDiscovered, CreatedAt: time.Now()}, // SeverityLow usa "Baixo"
			{ID: uuid.New(), OrganizationID: testOrgID, Title: "Vuln B", Severity: models.SeverityHigh, Status: models.VStatusRemediated, CreatedAt: time.Now()}, // SeverityHigh usa "Alto"
		}

		rows := sqlmock.NewRows([]string{"id", "organization_id", "title", "severity", "status", "created_at"}).
			AddRow(mockVulns[0].ID, mockVulns[0].OrganizationID, mockVulns[0].Title, mockVulns[0].Severity, mockVulns[0].Status, mockVulns[0].CreatedAt).
			AddRow(mockVulns[1].ID, mockVulns[1].OrganizationID, mockVulns[1].Title, mockVulns[1].Severity, mockVulns[1].Status, mockVulns[1].CreatedAt)

		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE organization_id = $1`)).
			WithArgs(testOrgID).
			WillReturnRows(rows)

		req, _ := http.NewRequest(http.MethodGet, "/vulnerabilities", nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)

		assert.Equal(t, http.StatusOK, rr.Code, "Response code should be 200 OK: %s", rr.Body.String())
		var vulns []models.Vulnerability
		err := json.Unmarshal(rr.Body.Bytes(), &vulns)
		assert.NoError(t, err)
		assert.Len(t, vulns, 2)
		assert.Equal(t, mockVulns[0].Title, vulns[0].Title)

		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})
}

// TODO: Add tests for UpdateVulnerabilityHandler and DeleteVulnerabilityHandler (DONE with basic auth)

func TestUpdateVulnerabilityHandler(t *testing.T) {
	setupMockDB(t)
	gin.SetMode(gin.TestMode)

	adminUserID := uuid.New()
	managerUserID := uuid.New()
	regularUserID := uuid.New()
	vulnToUpdateID := uuid.New()

	testCases := []struct {
		name           string
		actingUserID   uuid.UUID
		actingUserRole models.UserRole
		vulnID         uuid.UUID
		payload        VulnerabilityPayload
		mockDB         func(vID uuid.UUID, p VulnerabilityPayload, expectSave bool)
		expectedStatus int
		expectedBody   string
	}{
		{
			name:           "Successful update by Admin",
			actingUserID:   adminUserID,
			actingUserRole: models.RoleAdmin,
			vulnID:         vulnToUpdateID,
			payload:        VulnerabilityPayload{Title: "Admin Updated Vuln", Severity: models.SeverityCritical},
			mockDB: func(vID uuid.UUID, p VulnerabilityPayload, expectSave bool) {
				mockVulnerabilityFetch(vID, testOrgID)
				if expectSave {
					mockVulnerabilitySave(vID, p)
				}
			},
			expectedStatus: http.StatusOK,
			expectedBody:   "Admin Updated Vuln",
		},
		{
			name:           "Successful update by Manager",
			actingUserID:   managerUserID,
			actingUserRole: models.RoleManager,
			vulnID:         vulnToUpdateID,
			payload:        VulnerabilityPayload{Title: "Manager Updated Vuln", Severity: models.SeverityHigh},
			mockDB: func(vID uuid.UUID, p VulnerabilityPayload, expectSave bool) {
				mockVulnerabilityFetch(vID, testOrgID)
				if expectSave {
					mockVulnerabilitySave(vID, p)
				}
			},
			expectedStatus: http.StatusOK,
			expectedBody:   "Manager Updated Vuln",
		},
		{
			name:           "Forbidden update by Regular User",
			actingUserID:   regularUserID,
			actingUserRole: models.RoleUser,
			vulnID:         vulnToUpdateID,
			payload:        VulnerabilityPayload{Title: "User Update Attempt", Severity: models.SeverityLow},
			mockDB:         func(vID uuid.UUID, p VulnerabilityPayload, expectSave bool) { /* No DB interaction expected after auth fail */ },
			expectedStatus: http.StatusForbidden,
			expectedBody:   "You are not authorized to update vulnerabilities",
		},
		{
			name:           "Vulnerability not found for Admin",
			actingUserID:   adminUserID,
			actingUserRole: models.RoleAdmin,
			vulnID:         uuid.New(), // Different ID
			payload:        VulnerabilityPayload{Title: "Update Non-existent", Severity: models.SeverityMedium},
			mockDB: func(vID uuid.UUID, p VulnerabilityPayload, expectSave bool) {
				sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2`)).
					WithArgs(vID, testOrgID).
					WillReturnError(gorm.ErrRecordNotFound)
			},
			expectedStatus: http.StatusNotFound,
			expectedBody:   "Vulnerability not found",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			router := getRouterWithAuthContext(tc.actingUserID, testOrgID, tc.actingUserRole)
			router.PUT("/vulnerabilities/:vulnId", UpdateVulnerabilityHandler)

			if tc.mockDB != nil {
				tc.mockDB(tc.vulnID, tc.payload, tc.expectedStatus == http.StatusOK)
			}

			body, _ := json.Marshal(tc.payload)
			req, _ := http.NewRequest(http.MethodPut, fmt.Sprintf("/vulnerabilities/%s", tc.vulnID.String()), bytes.NewBuffer(body))
			req.Header.Set("Content-Type", "application/json")
			rr := httptest.NewRecorder()
			router.ServeHTTP(rr, req)

			assert.Equal(t, tc.expectedStatus, rr.Code, "Response code mismatch. Body: %s", rr.Body.String())
			if tc.expectedBody != "" {
				if tc.expectedStatus == http.StatusOK {
					var respVuln models.Vulnerability
					err := json.Unmarshal(rr.Body.Bytes(), &respVuln)
					assert.NoError(t, err)
					assert.Equal(t, tc.payload.Title, respVuln.Title)
				} else {
					assert.Contains(t, rr.Body.String(), tc.expectedBody)
				}
			}
			assert.NoError(t, sqlMock.ExpectationsWereMet(), "SQL mock expectations not met for: "+tc.name)
		})
	}
}

func mockVulnerabilityFetch(vulnID, orgID uuid.UUID) {
	rows := sqlmock.NewRows([]string{"id", "organization_id", "title", "severity", "status"}).
		AddRow(vulnID, orgID, "Original Vuln Title", models.SeverityHigh, models.VStatusDiscovered)
	sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2 ORDER BY "vulnerabilities"."id" LIMIT $3`)).
		WithArgs(vulnID, orgID, 1).
		WillReturnRows(rows)
}

func mockVulnerabilitySave(vulnID uuid.UUID, payload VulnerabilityPayload) {
	sqlMock.ExpectBegin()
	// This is a simplified mock for the save operation.
	// The actual fields in WithArgs would depend on GORM's update behavior (e.g., only changed fields).
	sqlMock.ExpectExec(regexp.QuoteMeta(`UPDATE "vulnerabilities" SET`)).
		WillReturnResult(sqlmock.NewResult(0, 1))
	sqlMock.ExpectCommit()
}


func TestDeleteVulnerabilityHandler(t *testing.T) {
	setupMockDB(t)
	gin.SetMode(gin.TestMode)

	adminUserID := uuid.New()
	managerUserID := uuid.New()
	regularUserID := uuid.New()
	vulnToDeleteID := uuid.New()

	testCases := []struct {
		name           string
		actingUserID   uuid.UUID
		actingUserRole models.UserRole
		vulnID         uuid.UUID
		mockDB         func(vID uuid.UUID, expectDelete bool)
		expectedStatus int
		expectedBody   string
	}{
		{
			name:           "Successful deletion by Admin",
			actingUserID:   adminUserID,
			actingUserRole: models.RoleAdmin,
			vulnID:         vulnToDeleteID,
			mockDB: func(vID uuid.UUID, expectDelete bool) {
				mockVulnerabilityFetch(vID, testOrgID) // Fetch before delete
				if expectDelete {
					mockVulnerabilityDelete(vID)
				}
			},
			expectedStatus: http.StatusOK,
			expectedBody:   "Vulnerability deleted successfully",
		},
		{
			name:           "Successful deletion by Manager",
			actingUserID:   managerUserID,
			actingUserRole: models.RoleManager,
			vulnID:         vulnToDeleteID,
			mockDB: func(vID uuid.UUID, expectDelete bool) {
				mockVulnerabilityFetch(vID, testOrgID)
				if expectDelete {
					mockVulnerabilityDelete(vID)
				}
			},
			expectedStatus: http.StatusOK,
			expectedBody:   "Vulnerability deleted successfully",
		},
		{
			name:           "Forbidden deletion by Regular User",
			actingUserID:   regularUserID,
			actingUserRole: models.RoleUser,
			vulnID:         vulnToDeleteID,
			mockDB:         func(vID uuid.UUID, expectDelete bool) { /* No DB interaction after auth fail */ },
			expectedStatus: http.StatusForbidden,
			expectedBody:   "You are not authorized to delete vulnerabilities",
		},
		{
			name:           "Vulnerability not found for Admin deletion",
			actingUserID:   adminUserID,
			actingUserRole: models.RoleAdmin,
			vulnID:         uuid.New(), // Different ID
			mockDB: func(vID uuid.UUID, expectDelete bool) {
				sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2`)).
					WithArgs(vID, testOrgID).
					WillReturnError(gorm.ErrRecordNotFound)
			},
			expectedStatus: http.StatusNotFound,
			expectedBody:   "Vulnerability not found",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			router := getRouterWithAuthContext(tc.actingUserID, testOrgID, tc.actingUserRole)
			router.DELETE("/vulnerabilities/:vulnId", DeleteVulnerabilityHandler)

			if tc.mockDB != nil {
				tc.mockDB(tc.vulnID, tc.expectedStatus == http.StatusOK)
			}

			req, _ := http.NewRequest(http.MethodDelete, fmt.Sprintf("/vulnerabilities/%s", tc.vulnID.String()), nil)
			rr := httptest.NewRecorder()
			router.ServeHTTP(rr, req)

			assert.Equal(t, tc.expectedStatus, rr.Code, "Response code mismatch. Body: %s", rr.Body.String())
			if tc.expectedBody != "" {
				assert.Contains(t, rr.Body.String(), tc.expectedBody)
			}
			assert.NoError(t, sqlMock.ExpectationsWereMet(), "SQL mock expectations not met for: "+tc.name)
		})
	}
}

func mockVulnerabilityDelete(vulnID uuid.UUID) {
	sqlMock.ExpectBegin()
	sqlMock.ExpectExec(regexp.QuoteMeta(`DELETE FROM "vulnerabilities" WHERE "vulnerabilities"."id" = $1`)).
		WithArgs(vulnID).
		WillReturnResult(sqlmock.NewResult(0, 1))
	sqlMock.ExpectCommit()
}
