package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"phoenixgrc/backend/internal/models" // Modelos, incluindo Vulnerability, VulnerabilitySeverity, etc.
	"regexp"                             // Para sqlmock query matching
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
)

// Assumindo que testUserID, testOrgID são definidos em main_test_handler.go e acessíveis.
// E que getRouterWithAuthenticatedContext também está disponível e configura o contexto Gin corretamente.

var testVulnID = uuid.New() // Para uso em testes Get, Update, Delete

func TestCreateVulnerabilityHandler(t *testing.T) {
	gin.SetMode(gin.TestMode)
	// Roteador com contexto de usuário autenticado (testUserID, testOrgID)
	// Assumindo que testUserID tem permissão (qualquer role autenticado pode criar para sua org)
	router := getRouterWithAuthenticatedContext(testUserID, testOrgID)
	router.POST("/vulnerabilities", CreateVulnerabilityHandler)

	t.Run("Successful vulnerability creation", func(t *testing.T) {
		payload := VulnerabilityPayload{
			Title:         "SQL Injection in Login Form",
			Description:   "User input in login form is not properly sanitized, allowing SQL injection.",
			CVEID:         "CVE-2023-12345",
			Severity:      models.SeverityHigh, // Uses "Alto"
			Status:        models.VStatusDiscovered,
			AssetAffected: "WebApp Login Page",
		}
		body, _ := json.Marshal(payload)

		sqlMock.ExpectBegin()
		// Regex para INSERT INTO "vulnerabilities"
		// Colunas: id, organization_id, title, description, cve_id, severity, status, asset_affected, created_at, updated_at
		sqlMock.ExpectQuery(regexp.QuoteMeta(`INSERT INTO "vulnerabilities" ("id","organization_id","title","description","cve_id","severity","status","asset_affected","created_at","updated_at") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING "id"`)).
			WithArgs(sqlmock.AnyArg(), testOrgID, payload.Title, payload.Description, payload.CVEID, payload.Severity, payload.Status, payload.AssetAffected, sqlmock.AnyArg(), sqlmock.AnyArg()).
			WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(uuid.New().String()))
		sqlMock.ExpectCommit()

		req, _ := http.NewRequest(http.MethodPost, "/vulnerabilities", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)

		assert.Equal(t, http.StatusCreated, rr.Code, "Response code should be 201 Created: %s", rr.Body.String())

		var createdVuln models.Vulnerability
		err := json.Unmarshal(rr.Body.Bytes(), &createdVuln)
		assert.NoError(t, err)
		assert.Equal(t, payload.Title, createdVuln.Title)
		assert.Equal(t, testOrgID, createdVuln.OrganizationID)
		assert.NotEqual(t, uuid.Nil, createdVuln.ID)

		assert.NoError(t, sqlMock.ExpectationsWereMet(), "SQL mock expectations were not met")
	})

	t.Run("Invalid payload - missing title", func(t *testing.T) {
		payload := VulnerabilityPayload{Description: "Only description", Severity: models.SeverityLow} // Title é obrigatório, SeverityLow usa "Baixo"
		body, _ := json.Marshal(payload)

		req, _ := http.NewRequest(http.MethodPost, "/vulnerabilities", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusBadRequest, rr.Code)
	})

    t.Run("Invalid payload - invalid severity", func(t *testing.T) {
		// Usando Marshal para criar um JSON com valor inválido para severity
		invalidPayloadJSON := `{"title": "Test Vuln", "severity": "super_high"}`

		req, _ := http.NewRequest(http.MethodPost, "/vulnerabilities", bytes.NewBuffer([]byte(invalidPayloadJSON)))
		req.Header.Set("Content-Type", "application/json")
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusBadRequest, rr.Code) // Gin binding deve falhar
	})
}

func TestGetVulnerabilityHandler(t *testing.T) {
	gin.SetMode(gin.TestMode)
	router := getRouterWithAuthenticatedContext(testUserID, testOrgID)
	router.GET("/vulnerabilities/:vulnId", GetVulnerabilityHandler)

	t.Run("Successful get vulnerability", func(t *testing.T) {
		mockVuln := models.Vulnerability{
			ID:             testVulnID,
			OrganizationID: testOrgID,
			Title:          "Test Vulnerability to Fetch",
			Severity:       models.SeverityMedium, // Uses "Médio"
			Status:         models.VStatusInRemediation,
			CreatedAt:      time.Now(),
			UpdatedAt:      time.Now(),
		}

		rows := sqlmock.NewRows([]string{"id", "organization_id", "title", "severity", "status", "created_at", "updated_at"}).
			AddRow(mockVuln.ID, mockVuln.OrganizationID, mockVuln.Title, mockVuln.Severity, mockVuln.Status, mockVuln.CreatedAt, mockVuln.UpdatedAt)

		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2 ORDER BY "vulnerabilities"."id" LIMIT $3`)).
			WithArgs(testVulnID, testOrgID, 1).
			WillReturnRows(rows)

		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("/vulnerabilities/%s", testVulnID.String()), nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)

		assert.Equal(t, http.StatusOK, rr.Code, "Response code should be 200 OK: %s", rr.Body.String())
		var fetchedVuln models.Vulnerability
		err := json.Unmarshal(rr.Body.Bytes(), &fetchedVuln)
		assert.NoError(t, err)
		assert.Equal(t, mockVuln.Title, fetchedVuln.Title)
		assert.Equal(t, mockVuln.ID, fetchedVuln.ID)

		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})

	t.Run("Vulnerability not found", func(t *testing.T) {
		nonExistentID := uuid.New()
		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2`)).
			WithArgs(nonExistentID, testOrgID).
			WillReturnError(gorm.ErrRecordNotFound)

		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("/vulnerabilities/%s", nonExistentID.String()), nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusNotFound, rr.Code)
		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})

    t.Run("Vulnerability belongs to another organization", func(t *testing.T) {
        otherOrgID := uuid.New() // Simula que o vulnID pertence a otherOrgID

        // Mock GORM para não encontrar o registro com testOrgID
		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE id = $1 AND organization_id = $2`)).
            WithArgs(testVulnID, testOrgID). // testVulnID é o ID, testOrgID é do token
			WillReturnError(gorm.ErrRecordNotFound) // O item não será encontrado para esta org

		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("/vulnerabilities/%s", testVulnID.String()), nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusNotFound, rr.Code) // Ou Forbidden, dependendo da lógica exata. NotFound é comum.
		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})
}


func TestListVulnerabilitiesHandler(t *testing.T) {
	gin.SetMode(gin.TestMode)
	router := getRouterWithAuthenticatedContext(testUserID, testOrgID)
	router.GET("/vulnerabilities", ListVulnerabilitiesHandler)

	t.Run("Successful list vulnerabilities", func(t *testing.T) {
		mockVulns := []models.Vulnerability{
			{ID: uuid.New(), OrganizationID: testOrgID, Title: "Vuln A", Severity: models.SeverityLow, Status: models.VStatusDiscovered, CreatedAt: time.Now()}, // SeverityLow usa "Baixo"
			{ID: uuid.New(), OrganizationID: testOrgID, Title: "Vuln B", Severity: models.SeverityHigh, Status: models.VStatusRemediated, CreatedAt: time.Now()}, // SeverityHigh usa "Alto"
		}

		rows := sqlmock.NewRows([]string{"id", "organization_id", "title", "severity", "status", "created_at"}).
			AddRow(mockVulns[0].ID, mockVulns[0].OrganizationID, mockVulns[0].Title, mockVulns[0].Severity, mockVulns[0].Status, mockVulns[0].CreatedAt).
			AddRow(mockVulns[1].ID, mockVulns[1].OrganizationID, mockVulns[1].Title, mockVulns[1].Severity, mockVulns[1].Status, mockVulns[1].CreatedAt)

		sqlMock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "vulnerabilities" WHERE organization_id = $1`)).
			WithArgs(testOrgID).
			WillReturnRows(rows)

		req, _ := http.NewRequest(http.MethodGet, "/vulnerabilities", nil)
		rr := httptest.NewRecorder()
		router.ServeHTTP(rr, req)

		assert.Equal(t, http.StatusOK, rr.Code, "Response code should be 200 OK: %s", rr.Body.String())
		var vulns []models.Vulnerability
		err := json.Unmarshal(rr.Body.Bytes(), &vulns)
		assert.NoError(t, err)
		assert.Len(t, vulns, 2)
		assert.Equal(t, mockVulns[0].Title, vulns[0].Title)

		assert.NoError(t, sqlMock.ExpectationsWereMet())
	})
}

// TODO: Add tests for UpdateVulnerabilityHandler and DeleteVulnerabilityHandler
// UpdateVulnerabilityHandler:
// - Successful update
// - Vulnerability not found for update
// - Invalid payload for update
// - Unauthorized update (e.g., trying to update a vulnerability of another org - though current logic might just show not found)
// DeleteVulnerabilityHandler:
// - Successful deletion
// - Vulnerability not found for deletion
// - Unauthorized deletion (similar to above)
