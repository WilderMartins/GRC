package handlers

import (
	"net/http"
	"phoenixgrc/backend/internal/database"
	"phoenixgrc/backend/internal/models"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

// VulnerabilityPayload defines the structure for creating or updating a vulnerability.
type VulnerabilityPayload struct {
	Title         string                      `json:"title" binding:"required,min=3,max=255"`
	Description   string                      `json:"description"`
	CVEID         string                      `json:"cve_id" binding:"omitempty,max=50"`
	Severity      models.VulnerabilitySeverity `json:"severity" binding:"required,oneof=Baixo Médio Alto Crítico"`
	Status        models.VulnerabilityStatus  `json:"status" binding:"omitempty,oneof=descoberta em_correcao corrigida"`
	AssetAffected string                      `json:"asset_affected" binding:"omitempty,max=255"`
}

// CreateVulnerabilityHandler handles the creation of a new vulnerability.
func CreateVulnerabilityHandler(c *gin.Context) {
	var payload VulnerabilityPayload
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}

	vulnerability := models.Vulnerability{
		OrganizationID: orgID.(uuid.UUID),
		Title:          payload.Title,
		Description:    payload.Description,
		CVEID:          payload.CVEID,
		Severity:       payload.Severity,
		Status:         payload.Status,
		AssetAffected:  payload.AssetAffected,
	}
	if vulnerability.Status == "" { // Set default status if not provided
		vulnerability.Status = models.VStatusDiscovered
	}

	db := database.GetDB()
	if err := db.Create(&vulnerability).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusCreated, vulnerability)
}

// GetVulnerabilityHandler handles fetching a single vulnerability by its ID.
func GetVulnerabilityHandler(c *gin.Context) {
	vulnIDStr := c.Param("vulnId")
	vulnID, err := uuid.Parse(vulnIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid vulnerability ID format"})
		return
	}

	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}

	db := database.GetDB()
	var vulnerability models.Vulnerability
	if err := db.Where("id = ? AND organization_id = ?", vulnID, orgID).First(&vulnerability).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found or not part of your organization"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, vulnerability)
}

// ListVulnerabilitiesHandler handles fetching all vulnerabilities for the organization.
// TODO: Implement pagination and filtering.
func ListVulnerabilitiesHandler(c *gin.Context) {
	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}

	db := database.GetDB()
	var vulnerabilities []models.Vulnerability
	if err := db.Where("organization_id = ?", orgID).Find(&vulnerabilities).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list vulnerabilities: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, vulnerabilities)
}

// UpdateVulnerabilityHandler handles updating an existing vulnerability.
func UpdateVulnerabilityHandler(c *gin.Context) {
	vulnIDStr := c.Param("vulnId")
	vulnID, err := uuid.Parse(vulnIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid vulnerability ID format"})
		return
	}

	var payload VulnerabilityPayload
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}

	db := database.GetDB()
	var vulnerability models.Vulnerability
	if err := db.Where("id = ? AND organization_id = ?", vulnID, orgID).First(&vulnerability).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found or not part of your organization for update"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch vulnerability for update: " + err.Error()})
		return
	}

	// Update fields from payload
	vulnerability.Title = payload.Title
	vulnerability.Description = payload.Description
	vulnerability.CVEID = payload.CVEID
	vulnerability.Severity = payload.Severity
	if payload.Status != "" { // Allow status update
		vulnerability.Status = payload.Status
	}
	vulnerability.AssetAffected = payload.AssetAffected

	if err := db.Save(&vulnerability).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, vulnerability)
}

// DeleteVulnerabilityHandler handles deleting a vulnerability.
func DeleteVulnerabilityHandler(c *gin.Context) {
	vulnIDStr := c.Param("vulnId")
	vulnID, err := uuid.Parse(vulnIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid vulnerability ID format"})
		return
	}

	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}

	db := database.GetDB()
	// Verify it exists and belongs to the organization before deleting.
	var vulnerability models.Vulnerability
	if err := db.Where("id = ? AND organization_id = ?", vulnID, orgID).First(&vulnerability).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found or not part of your organization for deletion"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch vulnerability for deletion: " + err.Error()})
		return
	}

	if err := db.Delete(&models.Vulnerability{}, vulnID).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Vulnerability deleted successfully"})
}
