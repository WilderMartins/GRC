package handlers

import (
	"encoding/csv"
	"fmt"
	"net/http"
	"phoenixgrc/backend/internal/database"
	"phoenixgrc/backend/internal/models"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

// VulnerabilityPayload defines the structure for creating or updating a vulnerability.
type VulnerabilityPayload struct {
	Title         string                      `json:"title" binding:"required,min=3,max=255"`
	Description   string                      `json:"description"`
	CVEID         string                      `json:"cve_id" binding:"omitempty,max=50"`
	Severity      models.VulnerabilitySeverity `json:"severity" binding:"required,oneof=Baixo Médio Alto Crítico"`
	Status        models.VulnerabilityStatus  `json:"status" binding:"omitempty,oneof=descoberta em_correcao corrigida"`
	AssetAffected string                      `json:"asset_affected" binding:"omitempty,max=255"`
	OwnerID       *uuid.UUID                  `json:"owner_id"` // Ponteiro para aceitar 'null'
}

// CreateVulnerabilityHandler handles the creation of a new vulnerability.
func CreateVulnerabilityHandler(c *gin.Context) {
	var payload VulnerabilityPayload
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}

	vulnerability := models.Vulnerability{
		OrganizationID: orgID.(uuid.UUID),
		Title:          payload.Title,
		Description:    payload.Description,
		CVEID:          payload.CVEID,
		Severity:       payload.Severity,
		Status:         payload.Status,
		AssetAffected:  payload.AssetAffected,
	}
	if vulnerability.Status == "" { // Set default status if not provided
		vulnerability.Status = models.VStatusDiscovered
	}

	db := database.GetDB()
	if err := db.Create(&vulnerability).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusCreated, vulnerability)
}

// GetVulnerabilityHandler handles fetching a single vulnerability by its ID.
func GetVulnerabilityHandler(c *gin.Context) {
	vulnIDStr := c.Param("vulnId")
	vulnID, err := uuid.Parse(vulnIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid vulnerability ID format"})
		return
	}

	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}

	db := database.GetDB()
	var vulnerability models.Vulnerability
	if err := db.Where("id = ? AND organization_id = ?", vulnID, orgID).First(&vulnerability).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found or not part of your organization"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, vulnerability)
}

// ListVulnerabilitiesHandler handles fetching all vulnerabilities for the organization with pagination.
func ListVulnerabilitiesHandler(c *gin.Context) {
	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}
	organizationID := orgID.(uuid.UUID)

	page, pageSize := GetPaginationParams(c) // Usando a função helper de common.go

	db := database.GetDB()
	var vulnerabilities []models.Vulnerability
	var totalItems int64

	// Contar o total de itens
	query := db.Model(&models.Vulnerability{}).Where("organization_id = ?", organizationID)

	// Aplicar filtros
	if status := c.Query("status"); status != "" {
		query = query.Where("status = ?", status)
	}
	if severity := c.Query("severity"); severity != "" {
		query = query.Where("severity = ?", severity)
	}
	if titleLike := c.Query("title_like"); titleLike != "" {
		query = query.Where("LOWER(title) LIKE LOWER(?)", "%"+titleLike+"%")
	}
	if cveId := c.Query("cve_id"); cveId != "" {
		query = query.Where("LOWER(cve_id) = LOWER(?)", cveId)
	}
	if assetAffectedLike := c.Query("asset_affected_like"); assetAffectedLike != "" {
		query = query.Where("LOWER(asset_affected) LIKE LOWER(?)", "%"+assetAffectedLike+"%")
	}

	if err := query.Count(&totalItems).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to count vulnerabilities: " + err.Error()})
		return
	}

	// Aplicar escopo de paginação e buscar os itens
	if err := query.Scopes(PaginateScope(page, pageSize)).Order("created_at desc").Find(&vulnerabilities).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list vulnerabilities: " + err.Error()})
		return
	}

	totalPages := totalItems / int64(pageSize)
	if totalItems%int64(pageSize) != 0 {
		totalPages++
	}
    if totalItems == 0 { totalPages = 0 }
    if totalPages == 0 && totalItems > 0 { totalPages = 1 }

	response := PaginatedResponse{
		Items:      vulnerabilities,
		TotalItems: totalItems,
		TotalPages: totalPages,
		Page:       page,
		PageSize:   pageSize,
	}

	c.JSON(http.StatusOK, response)
}

// UpdateVulnerabilityHandler handles updating an existing vulnerability.
func UpdateVulnerabilityHandler(c *gin.Context) {
	vulnIDStr := c.Param("vulnId")
	vulnID, err := uuid.Parse(vulnIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid vulnerability ID format"})
		return
	}

	var payload VulnerabilityPayload
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	orgIDToken, orgExists := c.Get("organizationID")
	userRoleToken, roleExists := c.Get("userRole")

	if !orgExists || !roleExists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Authentication token is missing required information."})
		return
	}
	organizationID := orgIDToken.(uuid.UUID)
	currentUserRole := userRoleToken.(models.UserRole)

	// Authorization: Only Admin or Manager can update vulnerabilities
	if currentUserRole != models.RoleAdmin && currentUserRole != models.RoleManager {
		c.JSON(http.StatusForbidden, gin.H{"error": "You are not authorized to update vulnerabilities."})
		return
	}

	db := database.GetDB()
	var vulnerability models.Vulnerability
	if err := db.Where("id = ? AND organization_id = ?", vulnID, organizationID).First(&vulnerability).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found or not part of your organization for update"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch vulnerability for update: " + err.Error()})
		return
	}

	// Update fields from payload
	vulnerability.Title = payload.Title
	vulnerability.Description = payload.Description
	vulnerability.CVEID = payload.CVEID
	vulnerability.Severity = payload.Severity
	if payload.Status != "" { // Allow status update
		vulnerability.Status = payload.Status
	}
	vulnerability.AssetAffected = payload.AssetAffected

	// A lógica de OwnerID foi removida do modelo Vulnerability.
	// TODO: Re-avaliar se vulnerabilidades devem ter um proprietário.
	// Se sim, o campo OwnerID deve ser readicionado ao models.Vulnerability
	// e a lógica de atribuição e notificação abaixo deve ser restaurada.

	if err := db.Save(&vulnerability).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, vulnerability)
}

// DeleteVulnerabilityHandler handles deleting a vulnerability.
func DeleteVulnerabilityHandler(c *gin.Context) {
	vulnIDStr := c.Param("vulnId")
	vulnID, err := uuid.Parse(vulnIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid vulnerability ID format"})
		return
	}

	orgIDToken, orgExists := c.Get("organizationID")
	userRoleToken, roleExists := c.Get("userRole")

	if !orgExists || !roleExists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Authentication token is missing required information."})
		return
	}
	organizationID := orgIDToken.(uuid.UUID)
	currentUserRole := userRoleToken.(models.UserRole)

	// Authorization: Only Admin or Manager can delete vulnerabilities
	if currentUserRole != models.RoleAdmin && currentUserRole != models.RoleManager {
		c.JSON(http.StatusForbidden, gin.H{"error": "You are not authorized to delete vulnerabilities."})
		return
	}

	db := database.GetDB()
	// Verify it exists and belongs to the organization before deleting.
	var vulnerability models.Vulnerability
	if err := db.Where("id = ? AND organization_id = ?", vulnID, organizationID).First(&vulnerability).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found or not part of your organization for deletion"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch vulnerability for deletion: " + err.Error()})
		return
	}

	if err := db.Delete(&vulnerability).Error; err != nil { // Changed to use the fetched instance
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete vulnerability: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Vulnerability deleted successfully"})
}

// ImportVulnerabilitiesCSVHandler handles bulk import of vulnerabilities from a CSV file.
func ImportVulnerabilitiesCSVHandler(c *gin.Context) {
	orgID, exists := c.Get("organizationID")
	if !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Organization ID not found in token"})
		return
	}
	organizationID := orgID.(uuid.UUID)

	file, _, err := c.Request.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "File is required"})
		return
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to read CSV file"})
		return
	}

	if len(records) < 2 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "CSV file must have a header and at least one data row"})
		return
	}

	header := records[0]
	// Create a map of header names to their column index
	headerMap := make(map[string]int)
	for i, h := range header {
		headerMap[strings.ToLower(strings.TrimSpace(h))] = i
	}

	// Check for required headers
	requiredHeaders := []string{"title", "severity", "asset_affected"}
	for _, rh := range requiredHeaders {
		if _, ok := headerMap[rh]; !ok {
			c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Missing required CSV header: %s", rh)})
			return
		}
	}

	var vulnerabilitiesToCreate []models.Vulnerability
	var vulnerabilitiesToUpdate []models.Vulnerability
	db := database.GetDB()

	for _, record := range records[1:] {
		title := record[headerMap["title"]]
		asset := record[headerMap["asset_affected"]]

		// Upsert logic: Check if a vulnerability with the same title and asset already exists
		var existingVuln models.Vulnerability
		err := db.Where("title = ? AND asset_affected = ? AND organization_id = ?", title, asset, organizationID).First(&existingVuln).Error

		vuln := models.Vulnerability{
			OrganizationID: organizationID,
			Title:          title,
			Severity:       models.VulnerabilitySeverity(record[headerMap["severity"]]),
			AssetAffected:  asset,
			Description:    getCSVField(record, headerMap, "description"),
			CVEID:          getCSVField(record, headerMap, "cveid"),
			Status:         models.VulnerabilityStatus(getCSVField(record, headerMap, "status")),
		}

		if vuln.Status == "" {
			vuln.Status = models.VStatusDiscovered
		}

		if err == gorm.ErrRecordNotFound {
			vulnerabilitiesToCreate = append(vulnerabilitiesToCreate, vuln)
		} else if err == nil {
			existingVuln.Severity = vuln.Severity
			existingVuln.Description = vuln.Description
			existingVuln.CVEID = vuln.CVEID
			existingVuln.Status = vuln.Status
			vulnerabilitiesToUpdate = append(vulnerabilitiesToUpdate, existingVuln)
		}
	}

	if len(vulnerabilitiesToCreate) > 0 {
		if err := db.Create(&vulnerabilitiesToCreate).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create new vulnerabilities"})
			return
		}
	}

	if len(vulnerabilitiesToUpdate) > 0 {
		for _, v := range vulnerabilitiesToUpdate {
			if err := db.Save(&v).Error; err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update existing vulnerabilities"})
				return
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"message":          "Vulnerabilities imported successfully",
		"created_count":    len(vulnerabilitiesToCreate),
		"updated_count":    len(vulnerabilitiesToUpdate),
	})
}

func getCSVField(record []string, headerMap map[string]int, fieldName string) string {
	if idx, ok := headerMap[fieldName]; ok && idx < len(record) {
		return record[idx]
	}
	return ""
}
