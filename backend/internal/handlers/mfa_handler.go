package handlers

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"image/png"
	"net/http"
	"phoenixgrc/backend/internal/database"
	"phoenixgrc/backend/internal/models"
	appConfig "phoenixgrc/backend/pkg/config" // Alias para o pacote de configuração

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/pquerna/otp/totp"
	"github.com/skip2/go-qrcode"
	"golang.org/x/crypto/bcrypt" // Added for password verification
)

type SetupTOTPResponse struct {
	Secret    string `json:"secret"`     // Base32 encoded secret
	QRCode    string `json:"qr_code"`    // Base64 encoded PNG image
	Account   string `json:"account"`    // User's email or identifier
	Issuer    string `json:"issuer"`     // Issuer name (from config)
	BackupCodesGenerated bool `json:"backup_codes_generated"` // Indica se novos códigos de backup foram gerados
}

// SetupTOTPHandler generates a new TOTP secret for the user and returns it along with a QR code.
// This endpoint is called when a user wants to start setting up TOTP.
// The TOTP is not yet enabled; it's only enabled after verification.
func SetupTOTPHandler(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User ID not found in token"})
		return
	}
	userUUID := userID.(uuid.UUID)

	db := database.GetDB()
	var user models.User
	if err := db.First(&user, "id = ?", userUUID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Generate a new TOTP key.
	// Issuer from config, account name is user's email.
	issuer := appConfig.Cfg.TOTPIssuerName
	if issuer == "" {
		issuer = "PhoenixGRC" // Fallback if not in config
	}

	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      issuer,
		AccountName: user.Email, // Use user's email as the account name in the OTP app
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate TOTP key: " + err.Error()})
		return
	}

	// Store the secret in the user's record.
	// IMPORTANT: In a real application, consider encrypting this secret at rest in the database.
	// For this implementation, we'll store it directly as generated by key.Secret() (Base32 string).
	user.TOTPSecret = key.Secret()
	// Reset IsTOTPEnabled to false because this is a new setup/re-setup.
	// It will be set to true only after successful verification.
	user.IsTOTPEnabled = false

	// Generate new backup codes when setting up a new TOTP secret.
	// For simplicity, this example does not implement backup codes yet.
	// This would involve generating a set of single-use codes, hashing them,
	// and storing the hashes. The plain codes are shown to the user once.
	// user.TOTPBackupCodes = "[]" // Placeholder for hashed backup codes as JSON array string

	// For now, we will skip backup code generation in this step.
	// It should be a separate, explicit action by the user after enabling TOTP.

	if err := db.Save(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save TOTP secret: " + err.Error()})
		return
	}

	// Generate QR code image.
	var qrCodeImage bytes.Buffer
	// The URL for the QR code is otpauth://totp/ISSUER:ACCOUNT?secret=SECRET&issuer=ISSUER
	// The key.String() method provides this URL.
	err = qrcode.Encode(key.String(), qrcode.Medium, 256) // Generate a 256x256 QR code
	if err != nil {
		// If direct Encode to writer fails (it shouldn't for bytes.Buffer), try generating png then encoding
		pngData, errPng := qrcode.Encode(key.String(), qrcode.Medium, 256)
		if errPng != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate QR code PNG data: " + errPng.Error()})
			return
		}
		_,_ = qrCodeImage.Write(pngData) // Write png to buffer
	} else {
		// This path might not be taken if qrcode.Encode directly to writer isn't a thing,
		// but qrcode.WriteColorPNG or similar might be. Let's assume qrcode.Encode returns []byte
		// For skip2/go-qrcode, qrcode.Encode returns []byte if writer is nil.
		// If we use qrcode.Write(&qrCodeImage, key.String(), qrcode.Medium, 256) it would write to buffer.
		// Let's adjust to use the common pattern of generating PNG bytes then base64 encoding.

		pngBytes, errPng := qrcode.Encode(key.String(), qrcode.Medium, 256)
		if errPng != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate QR code PNG: " + errPng.Error()})
			return
		}
		// For some reason, the above qrcode.Encode might not be working as expected with the library.
		// Let's try generating the PNG directly.
		img, errImg := qrcode.New(key.String(), qrcode.Medium)
		if errImg != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create QR code object: " + errImg.Error()})
			return
		}
		errPng = png.Encode(&qrCodeImage, img.Image(256))
		if errPng != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to encode QR code to PNG: " + errPng.Error()})
			return
		}
		pngBytes = qrCodeImage.Bytes() // Use the bytes from the buffer
	}


	response := SetupTOTPResponse{
		Secret:    key.Secret(), // The Base32 encoded secret string
		QRCode:    fmt.Sprintf("data:image/png;base64,%s", base64.StdEncoding.EncodeToString(qrCodeImage.Bytes())),
		Account:   user.Email,
		Issuer:    issuer,
		BackupCodesGenerated: false, // Set to true if backup codes were generated
	}

	c.JSON(http.StatusOK, response)
}

type VerifyTOTPPayload struct {
	Token string `json:"token" binding:"required"`
}

// VerifyTOTPHandler verifies a TOTP token provided by the user during setup or login.
// If called during setup, it enables TOTP for the user.
// If called during a 2FA login step, it would complete the login (logic to be added to login flow).
func VerifyTOTPHandler(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User ID not found in token"})
		return
	}
	userUUID := userID.(uuid.UUID)

	var payload VerifyTOTPPayload
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	db := database.GetDB()
	var user models.User
	if err := db.First(&user, "id = ?", userUUID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	if user.TOTPSecret == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "TOTP not set up for this user. Please set up TOTP first."})
		return
	}

	valid := totp.Validate(payload.Token, user.TOTPSecret)
	if !valid {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid TOTP token"})
		return
	}

	// If this is the first time verifying (i.e., enabling TOTP)
	if !user.IsTOTPEnabled {
		user.IsTOTPEnabled = true
		if err := db.Save(&user).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to enable TOTP: " + err.Error()})
			return
		}
		// TODO: Consider generating backup codes here and returning them.
		// For now, just confirm enablement.
		c.JSON(http.StatusOK, gin.H{"message": "TOTP successfully verified and enabled."})
		return
	}

	// If TOTP was already enabled, this endpoint might be used as a part of a 2FA login flow,
	// or just as a way to re-verify. For now, just a success message.
	// The actual login flow modification is a separate step.
	c.JSON(http.StatusOK, gin.H{"message": "TOTP token verified successfully."})
}

type DisableTOTPPayload struct {
	Password string `json:"password" binding:"required"`
}

// DisableTOTPHandler allows a user to disable TOTP for their account.
// Requires current password for verification.
func DisableTOTPHandler(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User ID not found in token"})
		return
	}
	userUUID := userID.(uuid.UUID)

	var payload DisableTOTPPayload
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	db := database.GetDB()
	var user models.User
	if err := db.First(&user, "id = ?", userUUID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Verify current password
	err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(payload.Password))
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid password"})
		return
	}

	if !user.IsTOTPEnabled {
		c.JSON(http.StatusBadRequest, gin.H{"error": "TOTP is not currently enabled for this account."})
		return
	}

	user.IsTOTPEnabled = false
	user.TOTPSecret = "" // Clear the secret
	// user.TOTPBackupCodes = "" // Clear backup codes if they were stored similarly

	if err := db.Save(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to disable TOTP: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "TOTP has been successfully disabled."})
}


// TODO: Implement GenerateBackupCodesHandler
// TODO: Implement VerifyBackupCodeHandler
// TODO: Modify LoginHandler to check for 2FA
// TODO: Create a new /auth/login/2fa/verify endpoint
```
