# PostgreSQL Database Configuration
POSTGRES_HOST=db # This should typically be the service name in docker-compose
POSTGRES_USER=admin
POSTGRES_PASSWORD=supersecretpassword
POSTGRES_DB=phoenix_grc_dev
POSTGRES_PORT=5432 # Host port to map to PostgreSQL container's 5432
POSTGRES_SSLMODE=disable # For local Docker development

# Application Specific
APP_ENV=development # General environment (not directly used by Go app yet, but good practice)
SERVER_PORT=8080    # Port the Go Gin server will listen on
GIN_MODE=debug      # Gin mode: debug, release, or test

# JWT Configuration
JWT_SECRET_KEY=your_very_secret_and_strong_jwt_key_here # CHANGE THIS IN PRODUCTION!
JWT_TOKEN_LIFESPAN_HOURS=24 # Token lifespan in hours (e.g., 1, 24, 72)

# Application Root URL (IMPORTANT for SAML and OAuth2 Callbacks)
# This should be the URL users use to access Phoenix GRC, and where IdPs will send back assertions.
# For local Docker development, if you access via localhost:8080, this is fine.
# In production, this will be your public domain, e.g., https://grc.mycompany.com
APP_ROOT_URL=http://localhost:8080

# SAML Service Provider (SP) Configuration - Phoenix GRC acts as SP
# These are the private key and public certificate for Phoenix GRC itself.
# The IdP will use the public certificate (from metadata) to encrypt assertions (optional)
# and to verify signatures on AuthnRequests sent by Phoenix GRC (if configured).
# Phoenix GRC uses its private key to decrypt encrypted assertions and to sign AuthnRequests.
#
# Generate these using OpenSSL or similar tools:
# 1. Generate a private key:
#    openssl genpkey -algorithm RSA -out saml_sp_private.key -pkeyopt rsa_keygen_bits:2048
# 2. Generate a self-signed public certificate from the private key:
#    openssl req -new -x509 -key saml_sp_private.key -out saml_sp_public.crt -days 3650 -subj "/CN=PhoenixGRC_SP"
#
# Then, copy the content of saml_sp_private.key into SAML_SP_KEY_PEM and
# saml_sp_public.crt into SAML_SP_CERT_PEM.
# IMPORTANT: In a real environment, use proper formatting for multi-line PEM strings
# (e.g., using `\n` in the .env file or loading from actual files).
# For .env files, often it's easier to base64 encode the PEM content and then decode in the app,
# or ensure your .env parser handles multi-line strings correctly.
# For simplicity here, we assume they might be single-line if manually edited or handled by a robust parser.
# Placeholder values - REPLACE WITH YOUR ACTUAL KEY AND CERTIFICATE:
SAML_SP_KEY_PEM="-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC0... REPLACE ...\n-----END PRIVATE KEY-----"
SAML_SP_CERT_PEM="-----BEGIN CERTIFICATE-----\nMIIDdzCCAl+gAwIBAgIJAN... REPLACE ...\n-----END CERTIFICATE-----"

# Frontend Redirect URLs (after successful SAML/OAuth2 login)
# These are URLs in your frontend application where users will be sent after auth.
# Both SAML and OAuth2 will now redirect to this generic callback page.
FRONTEND_SAML_CALLBACK_URL=http://localhost:3000/auth/callback
FRONTEND_OAUTH2_CALLBACK_URL=http://localhost:3000/auth/callback

# Note on IdentityProvider.ConfigJSON for OAuth2 (e.g., Google):
# When configuring an IdentityProvider of type 'oauth2_google' via the API,
# the 'config_json' field should look like this:
# {
#   "client_id": "YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com",
#   "client_secret": "YOUR_GOOGLE_CLIENT_SECRET",
#   "scopes": ["email", "profile"] // Optional, defaults to email & profile
# }
# The RedirectURI is constructed automatically by the backend based on APP_ROOT_URL and the IdP's ID.
# Ensure the constructed RedirectURI (e.g., http://localhost:8080/auth/oauth2/google/{idpId}/callback)
# is registered in your Google Cloud Console for the OAuth2 client.

# Google Cloud Storage (GCS) Configuration (for Audit Evidence Upload)
GCS_PROJECT_ID="your-gcp-project-id"
GCS_BUCKET_NAME="your-phoenixgrc-evidence-bucket-name"
# For local development with Docker, you might point this to a service account key JSON file
# that is volume-mounted into the container.
# e.g., GOOGLE_APPLICATION_CREDENTIALS=/app/gcp_credentials.json
# In GCP production environments (Cloud Run, GKE, App Engine), credentials can often be implicit.
GOOGLE_APPLICATION_CREDENTIALS="" # Path to GCP service account key file (JSON)

# AWS Simple Email Service (SES) Configuration
AWS_REGION="us-east-1" # Your AWS SES region
AWS_ACCESS_KEY_ID=""   # Your AWS Access Key ID (for dev/local)
AWS_SECRET_ACCESS_KEY="" # Your AWS Secret Access Key (for dev/local)
# In production on AWS (EC2, ECS, Lambda), use IAM Roles for credentials instead of hardcoding keys.
EMAIL_SENDER_ADDRESS="noreply@example.com" # Verified sender email address in SES
