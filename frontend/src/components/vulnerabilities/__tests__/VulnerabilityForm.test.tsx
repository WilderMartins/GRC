import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import VulnerabilityForm from '../VulnerabilityForm'; // Ajuste o path
import apiClient from '@/lib/axios'; // Para mockar apiClient
import '@testing-library/jest-dom';
import { AuthContext } from '@/contexts/AuthContext'; // Para prover mock de user

// Mock Next.js Router
jest.mock('next/router', () => ({
  useRouter: jest.fn(() => ({
    push: jest.fn(),
  })),
}));

// Mock apiClient (axios)
jest.mock('@/lib/axios');
const mockedApiClient = apiClient as jest.Mocked<typeof apiClient>;

// Mock do AuthContext
const mockUser = { id: 'user123', name: 'Test User', email: 'test@example.com', role: 'admin', organization_id: 'org1' };
const mockAuthContextValue = {
  isAuthenticated: true,
  user: mockUser,
  token: 'fake-token',
  isLoading: false,
  login: jest.fn(),
  logout: jest.fn(),
};

const renderFormWithAuthProvider = (props?: any) => {
    return render(
        <AuthContext.Provider value={mockAuthContextValue}>
            <VulnerabilityForm {...props} />
        </AuthContext.Provider>
    );
}


describe('VulnerabilityForm', () => {
  beforeEach(() => {
    mockedApiClient.post.mockReset();
    mockedApiClient.put.mockReset();
    window.alert = jest.fn(); // Mock window.alert
  });

  it('renders all form fields correctly for new vulnerability', () => {
    renderFormWithAuthProvider();
    expect(screen.getByLabelText(/Título da Vulnerabilidade/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Descrição/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/CVE ID/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Ativo Afetado/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Severidade/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Status/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /Criar Vulnerabilidade/i })).toBeInTheDocument();
  });

  it('submits new vulnerability data correctly', async () => {
    const mockPush = jest.fn();
    (useRouter as jest.Mock).mockReturnValue({ push: mockPush });
    mockedApiClient.post.mockResolvedValue({ data: { id: 'new-vuln-id' } }); // Simula resposta da API

    renderFormWithAuthProvider();

    fireEvent.change(screen.getByLabelText(/Título da Vulnerabilidade/i), { target: { value: 'Nova Vuln' } });
    fireEvent.change(screen.getByLabelText(/Severidade/i), { target: { value: 'Alto' } });
    // Preencher outros campos se necessário para validação

    fireEvent.click(screen.getByRole('button', { name: /Criar Vulnerabilidade/i }));

    await waitFor(() => {
      expect(mockedApiClient.post).toHaveBeenCalledWith('/vulnerabilities', expect.objectContaining({
        title: 'Nova Vuln',
        severity: 'Alto',
      }));
    });
    expect(window.alert).toHaveBeenCalledWith('Vulnerabilidade criada com sucesso!');
    expect(mockPush).toHaveBeenCalledWith('/admin/vulnerabilities');
  });

  it('pre-fills form with initialData for editing and submits correctly', async () => {
    const mockPush = jest.fn();
    (useRouter as jest.Mock).mockReturnValue({ push: mockPush });
    mockedApiClient.put.mockResolvedValue({ data: { id: 'vuln-to-edit' } });

    const initialTestData = {
      id: 'vuln-to-edit',
      title: 'Vuln Existente',
      description: 'Desc',
      cve_id: 'CVE-TEST-1',
      severity: 'Médio' as "Baixo" | "Médio" | "Alto" | "Crítico", // Cast para o tipo esperado
      status: 'em_correcao' as "descoberta" | "em_correcao" | "corrigida",
      asset_affected: 'Servidor X',
    };

    renderFormWithAuthProvider({ initialData: initialTestData, isEditing: true });

    expect((screen.getByLabelText(/Título da Vulnerabilidade/i) as HTMLInputElement).value).toBe('Vuln Existente');
    expect((screen.getByLabelText(/Severidade/i) as HTMLSelectElement).value).toBe('Médio');

    fireEvent.change(screen.getByLabelText(/Título da Vulnerabilidade/i), { target: { value: 'Vuln Editada' } });
    fireEvent.click(screen.getByRole('button', { name: /Salvar Alterações/i }));

    await waitFor(() => {
      expect(mockedApiClient.put).toHaveBeenCalledWith('/vulnerabilities/vuln-to-edit', expect.objectContaining({
        title: 'Vuln Editada',
      }));
    });
    expect(window.alert).toHaveBeenCalledWith('Vulnerabilidade atualizada com sucesso!');
    expect(mockPush).toHaveBeenCalledWith('/admin/vulnerabilities');
  });

  it('shows error message if required fields are missing on submit', async () => {
    renderFormWithAuthProvider();
    fireEvent.click(screen.getByRole('button', { name: /Criar Vulnerabilidade/i }));

    // O formulário tem 'required' no HTML, mas o handler JS também valida.
    // Aqui, estamos testando a validação JS dentro do handler.
    // O `VulnerabilityForm` tem validação para `severity`.
    expect(await screen.findByText(/Severidade é obrigatória./i)).toBeInTheDocument();
    expect(mockedApiClient.post).not.toHaveBeenCalled();
  });

});
